# [OPT-001]: K-D Tree Construction Allocations

## Impact
MEDIUM

## Category
Memory / Performance

## Location
- File: [src/utils/kd-tree.ts](../../xivdyetools-core/src/utils/kd-tree.ts)
- Line(s): 48-98
- Function: buildTreeOptimized()

## Current Performance
The k-d tree implementation includes a CORE-PERF-002 optimization that uses index arrays instead of slicing point arrays. However, there are still opportunities for further optimization.

## Bottleneck Analysis

**Current Implementation:**
```typescript
// Line 51: Creates index array (good optimization)
const indices = points.map((_, i) => i);
this.root = this.buildTreeOptimized(points, indices, 0);

// Lines 94-95: Still creates new index arrays via slice (allocation overhead)
node.left = this.buildTreeOptimized(points, indices.slice(0, median), depth + 1);
node.right = this.buildTreeOptimized(points, indices.slice(median + 1), depth + 1);
```

**Performance Characteristics:**
- **Time Complexity:** O(n log² n) - optimal for k-d tree construction
- **Space Complexity:** O(n log n) due to index array slices
- **Memory Allocations:** ~2n slice operations (one per recursive call)

**Benchmarking Needed:**
For a dye database with ~200 dyes:
- Total index arrays created: ~400 (2 per node × ~200 nodes)
- Memory overhead: ~400 arrays × 8 bytes per entry × average size
- GC pressure: Moderate (depends on rebuild frequency)

## Proposed Optimization

### Optimization Strategy: Index Bounds Instead of Slicing
Instead of creating new index arrays at each level, pass start/end indices:

```typescript
/**
 * Optimized k-d tree construction with zero index array allocations
 * Uses index bounds instead of array slicing to eliminate GC pressure
 */
private buildTreeOptimized(
  points: Point3D[],
  indices: number[],
  start: number,
  end: number,
  depth: number
): KDNode | null {
  const length = end - start;
  if (length === 0) {
    return null;
  }

  if (length === 1) {
    return new KDNode(points[indices[start]], depth % 3);
  }

  // Select dimension to split on (alternate R, G, B)
  const dimension = depth % 3;

  // Sort indices in-place within bounds
  this.sortIndicesInRange(indices, start, end, points, dimension);

  // Find median within bounds
  const median = start + Math.floor(length / 2);
  const medianPoint = points[indices[median]];

  // Create node
  const node = new KDNode(medianPoint, dimension);

  // Recursively build subtrees using index bounds (zero allocations)
  node.left = this.buildTreeOptimized(points, indices, start, median, depth + 1);
  node.right = this.buildTreeOptimized(points, indices, median + 1, end, depth + 1);

  return node;
}

/**
 * Sort indices within a range in-place
 */
private sortIndicesInRange(
  indices: number[],
  start: number,
  end: number,
  points: Point3D[],
  dimension: number
): void {
  // Sort only the range [start, end) in the indices array
  const slice = indices.slice(start, end);
  slice.sort((a, b) => {
    const aPoint = points[a];
    const bPoint = points[b];
    const aVal = dimension === 0 ? aPoint.x : dimension === 1 ? aPoint.y : aPoint.z;
    const bVal = dimension === 0 ? bPoint.x : dimension === 1 ? bPoint.y : bPoint.z;
    return aVal - bVal;
  });
  // Copy sorted values back
  for (let i = 0; i < slice.length; i++) {
    indices[start + i] = slice[i];
  }
}
```

**Wait, this still uses slice!** Let me provide a truly zero-allocation version:

```typescript
/**
 * Truly zero-allocation k-d tree construction
 * Uses in-place quickselect for median finding
 */
private buildTreeOptimized(
  points: Point3D[],
  indices: number[],
  start: number,
  end: number,
  depth: number
): KDNode | null {
  const length = end - start;
  if (length === 0) {
    return null;
  }

  if (length === 1) {
    return new KDNode(points[indices[start]], depth % 3);
  }

  const dimension = depth % 3;
  const medianIndex = start + Math.floor(length / 2);

  // Use quickselect to partition around median (in-place, O(n) average)
  this.quickselect(indices, start, end, medianIndex, points, dimension);

  const medianPoint = points[indices[medianIndex]];
  const node = new KDNode(medianPoint, dimension);

  // Build subtrees with zero allocations
  node.left = this.buildTreeOptimized(points, indices, start, medianIndex, depth + 1);
  node.right = this.buildTreeOptimized(points, indices, medianIndex + 1, end, depth + 1);

  return node;
}

/**
 * In-place quickselect algorithm (Floyd-Rivest variant)
 * Partitions array so indices[k] is in correct position
 * Average O(n), worst-case O(n²) but very rare with good pivot selection
 */
private quickselect(
  indices: number[],
  left: number,
  right: number,
  k: number,
  points: Point3D[],
  dimension: number
): void {
  while (right > left) {
    // Use median-of-three for pivot selection
    const pivotIndex = this.medianOfThree(indices, left, right, points, dimension);
    const newPivot = this.partition(indices, left, right, pivotIndex, points, dimension);

    if (newPivot === k) {
      return;
    } else if (k < newPivot) {
      right = newPivot - 1;
    } else {
      left = newPivot + 1;
    }
  }
}

private partition(
  indices: number[],
  left: number,
  right: number,
  pivotIndex: number,
  points: Point3D[],
  dimension: number
): number {
  const pivotValue = this.getValueAtDimension(points[indices[pivotIndex]], dimension);

  // Move pivot to end
  this.swap(indices, pivotIndex, right);

  let storeIndex = left;
  for (let i = left; i < right; i++) {
    const value = this.getValueAtDimension(points[indices[i]], dimension);
    if (value < pivotValue) {
      this.swap(indices, i, storeIndex);
      storeIndex++;
    }
  }

  // Move pivot to final position
  this.swap(indices, storeIndex, right);
  return storeIndex;
}

private swap(arr: number[], i: number, j: number): void {
  const temp = arr[i];
  arr[i] = arr[j];
  arr[j] = temp;
}

private getValueAtDimension(point: Point3D, dimension: number): number {
  return dimension === 0 ? point.x : dimension === 1 ? point.y : point.z;
}

private medianOfThree(
  indices: number[],
  left: number,
  right: number,
  points: Point3D[],
  dimension: number
): number {
  const mid = left + Math.floor((right - left) / 2);
  const leftVal = this.getValueAtDimension(points[indices[left]], dimension);
  const midVal = this.getValueAtDimension(points[indices[mid]], dimension);
  const rightVal = this.getValueAtDimension(points[indices[right]], dimension);

  if (leftVal > midVal) {
    if (midVal > rightVal) return mid;
    return leftVal > rightVal ? right : left;
  } else {
    if (leftVal > rightVal) return left;
    return midVal > rightVal ? right : mid;
  }
}
```

## Expected Improvement
**Memory Allocations:**
- Current: ~400 array slices (2 per node)
- Optimized: 1 initial index array (zero during recursion)
- **Reduction: 99.75% fewer allocations**

**Performance Impact:**
- Build time: ~10-20% faster (reduced GC, better cache locality)
- Memory usage: ~50% reduction during construction
- GC pressure: Significantly reduced

**Trade-offs:**
- Code complexity: Higher (quickselect vs. simple sort)
- Worst-case: O(n²) vs. O(n log n) for quickselect (very rare with median-of-three pivot)
- Debugging: Slightly harder due to in-place mutations

## Benchmark Approach
```typescript
// Benchmark harness
const points = generateTestPoints(200); // Current dye database size
const runs = 1000;

console.time('Current Implementation');
for (let i = 0; i < runs; i++) {
  new KDTree(points);
}
console.timeEnd('Current Implementation');

console.time('Optimized Implementation');
for (let i = 0; i < runs; i++) {
  new OptimizedKDTree(points);
}
console.timeEnd('Optimized Implementation');
```

## Recommendation
**MEDIUM PRIORITY** - Optimize if profiling shows k-d tree construction is a bottleneck

**When to Optimize:**
- If tree is rebuilt frequently (not just on initialization)
- If working with larger datasets (1000+ colors)
- If memory pressure is detected in production

**When NOT to Optimize:**
- Tree is only built once on initialization ✅ (Current use case)
- Dataset remains small (~200 dyes) ✅ (Current use case)
- Complexity cost outweighs performance gain

**Current Status:**
The existing CORE-PERF-002 optimization is sufficient for the current use case (one-time construction with 200 dyes). The proposed optimization would be beneficial for:
- Real-time tree rebuilding
- Dynamic dye database updates
- Larger color databases (1000+ colors)

## References
- Quickselect Algorithm: https://en.wikipedia.org/wiki/Quickselect
- K-D Tree Construction: https://en.wikipedia.org/wiki/K-d_tree#Construction
- Floyd-Rivest Algorithm: https://en.wikipedia.org/wiki/Floyd%E2%80%93Rivest_algorithm
