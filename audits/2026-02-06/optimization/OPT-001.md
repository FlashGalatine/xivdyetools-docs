# OPT-001: World/DataCenter Autocomplete Fetches on Every Keystroke

## Impact
HIGH

## Category
I/O Optimization / Caching

## Location
- File: src/services/budget/universalis-client.ts
- Function: getWorldAutocomplete() (lines 328-371)

## Current Performance
Every autocomplete keystroke triggers two HTTP requests via Service Binding (or external URL):
- `fetchWorlds()` → GET /api/v2/worlds
- `fetchDataCenters()` → GET /api/v2/data-centers

Discord autocomplete fires on every character typed, meaning a user typing "Crystal" triggers 7 pairs of requests (14 total). Worlds and data centers in FFXIV change perhaps once every 2-3 years.

## Bottleneck Analysis
Each Service Binding call has ~1-5ms overhead. External URL calls would be 50-200ms. Multiplied by the frequency of autocomplete requests, this creates unnecessary load on the Universalis proxy worker.

The same issue affects `validateWorld()` (line 294) which also calls both `fetchWorlds()` and `fetchDataCenters()`.

Additionally, the `/preferences set world:...` autocomplete path (index.ts:664) also calls `getWorldAutocomplete()`.

## Proposed Optimization
Cache world and datacenter data in module-level variables with a long TTL:

```typescript
let worldsCache: { data: UniversalisWorld[]; fetchedAt: number } | null = null;
let dcCache: { data: UniversalisDataCenter[]; fetchedAt: number } | null = null;
const WORLD_CACHE_TTL = 3600_000; // 1 hour (worlds rarely change)

async function getCachedWorlds(env: Env, logger?: ExtendedLogger): Promise<UniversalisWorld[]> {
  if (worldsCache && Date.now() - worldsCache.fetchedAt < WORLD_CACHE_TTL) {
    return worldsCache.data;
  }
  const worlds = await fetchWorlds(env, logger);
  worldsCache = { data: worlds, fetchedAt: Date.now() };
  return worlds;
}
```

## Expected Improvement
- Autocomplete latency: from ~5-200ms to <1ms for cached responses
- Universalis proxy load: reduced by ~95% for autocomplete traffic
- User experience: faster autocomplete suggestions

## Trade-offs
- Stale data possible for up to 1 hour (acceptable since worlds rarely change)
- Module-level cache is per-isolate, so different isolates may cache at different times
- Memory usage: ~5KB for world/DC data (negligible)

## Benchmark Approach
- Count Service Binding calls before/after using logger
- Measure autocomplete response time via Analytics Engine latency tracking
