# OPT-003: Price Cache Individual Key Lookups Per Item

## Impact
MEDIUM

## Category
I/O Optimization / Caching Strategy

## Location
- File: src/services/budget/price-cache.ts
- Function: getCachedPrices() (lines 182-199)

## Current Performance
The `getCachedPrices()` function issues a parallel `cache.match()` for EACH item ID. For 136 dyes, that's 136 individual Cache API lookups running in parallel.

While Cache API lookups are fast (~0.1-1ms each), 136 parallel lookups create scheduling overhead and many small I/O operations.

## Bottleneck Analysis
Each `cache.match()` call involves:
1. URL string construction
2. Cache key lookup (Cloudflare's cache infrastructure)
3. Response deserialization (JSON parse)

With 136 items, the aggregate latency is dominated by the slowest lookup (tail latency).

## Proposed Optimization
Use a single composite cache key per world instead of per-item keys:

```typescript
// Single cache key for all prices in a world
const WORLD_PRICES_URL = `${CACHE_BASE_URL}/${CACHE_SCHEMA_VERSION}/world-prices/${world}`;

export async function getCachedWorldPrices(
  world: string,
  logger?: ExtendedLogger
): Promise<Map<number, DyePriceData> | null> {
  const cache = caches.default;
  const response = await cache.match(WORLD_PRICES_URL);
  if (!response) return null;

  const entry = await response.json() as {
    prices: Record<number, DyePriceData>;
    cachedAt: number;
  };

  // Check freshness
  if (Date.now() - entry.cachedAt > CACHE_TTL_SECONDS * 1000) {
    return null;
  }

  return new Map(Object.entries(entry.prices).map(([k, v]) => [Number(k), v]));
}
```

## Expected Improvement
- Cache lookups: from 136 to 1 per budget command
- Latency: ~5-15ms â†’ ~1-3ms for cache hits
- Cache storage: slightly more efficient (one entry vs. 136 entries)

## Trade-offs
- All-or-nothing caching: if one dye's price updates, the entire world cache must be invalidated
- Cache entry is larger (~50KB for all dyes vs. ~400 bytes per dye)
- Current per-item approach is more granular for partial cache fills

## Benchmark Approach
- Compare `getCachedPrices()` latency for 136 items: individual vs. composite key
- Measure cache hit rate before/after
