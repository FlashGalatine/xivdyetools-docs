# BUG-007: Unique User Tracking Race Condition and Unbounded Growth

## Severity
LOW

## Type
Race Condition / Resource Growth

## Location
- File: src/services/analytics.ts
- Line(s): 181-195
- Function: trackUniqueUser()

## Description
Two issues with unique user tracking:

1. **Race condition**: Multiple concurrent calls read the existing comma-separated list, add their user ID, and write back. If two requests read at the same time, one write will overwrite the other's addition.

2. **Unbounded growth**: User IDs are accumulated as comma-separated strings in a single KV value. A Discord user ID is ~18 chars, so with 1,000 daily users, the value would be ~20KB. With 10,000 users, it would be ~200KB. While under KV's 25MiB limit, reading and parsing large strings for every command execution is wasteful.

## Evidence
```typescript
export async function trackUniqueUser(kv: KVNamespace, userId: string): Promise<void> {
  const today = new Date().toISOString().split('T')[0];
  const key = `${STATS_PREFIX}users:${today}`;

  // RACE: Two concurrent reads get the same existing value
  const existing = await kv.get(key);
  const users = new Set(existing ? existing.split(',') : []);

  users.add(userId);
  // RACE: Whichever writes last wins, potentially losing the other's addition
  await kv.put(key, Array.from(users).join(','), { expirationTtl: STATS_TTL });
}
```

## Suggested Fix
For accurate unique user counting, use HyperLogLog in Analytics Engine, or use a separate KV key per user (`stats:users:2026-02-06:{userId}`) with TTL, and count via `list()`.

## Why It's Hidden
- Analytics is fire-and-forget, so lost increments don't affect user experience
- The race window is small for low-traffic bots
- Growth is self-limiting by TTL (30-day expiry)
