# BUG-001: LocalizationService Singleton Race Condition

## Severity
CRITICAL

## Type
Race Condition / Concurrency

## Location
- File: src/services/i18n.ts
- Line(s): 228-243
- Function: initializeLocale()

## Description
`LocalizationService` from `@xivdyetools/core` is a singleton. The `initializeLocale()` function calls `LocalizationService.clear()` then `LocalizationService.setLocale(locale)`. When Cloudflare Workers processes multiple concurrent requests within the same isolate (which happens during I/O waits like `await fetch()`), one request can clear/set the locale while another request is mid-way through reading dye names with a different locale.

For example:
1. Request A (Japanese user) calls `initializeLocale('ja')`
2. Request A awaits SVG rendering (yields execution)
3. Request B (English user) calls `initializeLocale('en')` --- this calls `clear()` + `setLocale('en')`
4. Request A resumes and calls `getLocalizedDyeName()` --- gets English names instead of Japanese

## Reproduction Scenario
Two concurrent `/harmony` commands from users with different language preferences on the same Worker isolate. The background processing in `processHarmonyCommand` and `processFindCommand` both call `initializeLocale()`, which mutates global state.

## Evidence
```typescript
// i18n.ts:228-243
export async function initializeLocale(
  locale: LocaleCode,
  logger?: ExtendedLogger
): Promise<void> {
  try {
    // RACE: clear() destroys state for ALL concurrent requests
    LocalizationService.clear();
    await LocalizationService.setLocale(locale);
  } catch (error) {
    // ...
    LocalizationService.clear();
    await LocalizationService.setLocale('en');
  }
}
```

Multiple background tasks call this:
- `harmony.ts:146` --- `await initializeLocale(locale);`
- `budget.ts:192` --- `await initializeLocale(t.getLocale(), logger);`
- `extractor.ts:480` --- `await initializeLocale(locale);`
- `favorites.ts:91` --- `await initializeLocale(t.getLocale());`
- `collection.ts:98` --- `await initializeLocale(locale);`

## Suggested Fix
Pass locale as a parameter to `getLocalizedDyeName()` instead of relying on global singleton state, or use a request-scoped localization approach:

```typescript
// Option 1: Pass locale explicitly to each call
export function getLocalizedDyeName(
  itemID: number,
  fallbackName: string,
  locale: LocaleCode  // Add locale parameter
): string {
  // Use locale-specific lookup instead of singleton
}

// Option 2: Create per-request localization instances
const localizer = new LocalizationService(locale);
const name = localizer.getDyeName(itemID);
```

## Why It's Hidden
- Only manifests under concurrent load with users of different languages
- In development/testing, there's typically only one request at a time
- The race window is short (between clear/setLocale and subsequent reads)
- English-only users would never notice since English is the fallback
