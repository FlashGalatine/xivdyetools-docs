# BUG-006: Rate Limiter Singleton Never Recovers After Fallback

## Severity
LOW

## Type
State Management

## Location
- File: src/services/rate-limiter.ts
- Line(s): 56-91
- Function: getLimiter()

## Description
The rate limiter uses a module-level singleton pattern. Once initialized (e.g., with Upstash), it never re-evaluates. This is generally fine, but if the initial configuration check happens when Upstash credentials are not yet available (e.g., during a cold start race), it would fall back to KV and stay there permanently for that isolate's lifetime.

More importantly, `getLimiter()` only checks `if (limiterInstance && configuredBackend)` --- it never verifies that the configured instance is still healthy or that a preferred backend became available.

## Reproduction Scenario
1. Worker cold starts, Upstash vars not populated yet (deployment timing)
2. `getLimiter()` creates KV fallback
3. Upstash vars become available
4. All subsequent requests in this isolate use KV instead of Upstash
5. KV-based rate limiting is less accurate (no atomic operations)

## Evidence
```typescript
let limiterInstance: RateLimiter | null = null;
let configuredBackend: 'upstash' | 'kv' | null = null;

function getLimiter(config: RateLimiterConfig): RateLimiter {
  if (limiterInstance && configuredBackend) {
    return limiterInstance;  // <- Once set, never re-evaluated
  }
  // ...
}
```

## Suggested Fix
This is low severity because Workers redeploy creates fresh isolates. If needed, add periodic re-evaluation or simply accept the current behavior with a comment explaining the trade-off.

## Why It's Hidden
- Upstash credentials are almost always available at cold start
- The fail-open policy means requests aren't blocked either way
- The difference between KV and Upstash rate limiting is subtle
