# BUG-005: GitHub Webhook Body Size Check After Full Read

## Severity
LOW

## Type
Resource Consumption / Defense-in-Depth

## Location
- File: src/index.ts
- Line(s): 288-294
- Function: GitHub webhook handler

## Description
The GitHub webhook handler reads the ENTIRE request body into memory with `c.req.text()` BEFORE checking the size. A malicious or misconfigured webhook could send a large payload that would be fully buffered before being rejected.

Compare with the preset webhook handler which checks `Content-Length` header BEFORE reading the body (though that check can also be bypassed).

## Reproduction Scenario
An attacker sends a POST to `/webhooks/github` with a valid GitHub signature but a 50MB payload. The worker reads 50MB into memory, then checks `rawBody.length > 10240` and rejects it --- after the damage is done.

## Evidence
```typescript
// GitHub webhook (line 288) --- reads body FIRST, checks size SECOND
const rawBody = await c.req.text();          // <- Full body read
if (rawBody.length > 10240) {                // <- Size check AFTER read
  return c.json({ error: 'Payload too large' }, 413);
}

// Preset webhook (line 164) --- checks Content-Length FIRST (better)
const contentLength = parseInt(c.req.header('content-length') || '0', 10);
if (contentLength > 10240) {                 // <- Size check BEFORE read
  return c.json({ error: 'Payload too large' }, 413);
}
```

## Suggested Fix
Check Content-Length header first, then read body with size limit:

```typescript
// Check Content-Length header first
const contentLength = parseInt(c.req.header('content-length') || '0', 10);
if (contentLength > 10240) {
  return c.json({ error: 'Payload too large' }, 413);
}

// Read with confidence (or use streaming with limit)
const rawBody = await c.req.text();
if (rawBody.length > 10240) {
  return c.json({ error: 'Payload too large' }, 413);
}
```

## Why It's Hidden
- GitHub webhooks typically send small payloads (< 1KB for push events)
- Cloudflare Workers have memory limits that provide a safety net
- The signature verification would fail for crafted payloads anyway
